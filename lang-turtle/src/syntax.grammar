@top TurtleDoc { (statement '.'*)* }         /* [1] 	turtleDoc 	::= 	statement* */

@skip { space | LineComment }

// https://www.w3.org/TR/turtle/#sec-grammar-grammar

statement { Directive | Triples '.' }                                     // [2]  statement    ::= directive | triples '.'
Directive { PrefixID | Base | SparqlPrefix | SparqlBase }                       // [3] 	directive    ::= prefixID | base | sparqlPrefix | sparqlBase
PrefixID { '@prefix' PN_PREFIX ':' IRIREF '.' }                                      // [4] 	prefixID     ::= '@prefix' PNAME_NS IRIREF '.'
Base { '@base' IRIREF '.' }                                                     // [5]  base         ::= '@base' IRIREF '.'
SparqlBase { base_token IRIREF  }                                       // [5s] sparqlBase   ::= "BASE" IRIREF
SparqlPrefix { prefix_token PN_PREFIX ':' IRIREF }                                           // [6s] sparqlPrefix ::= "PREFIX" PNAME_NS IRIREF



Triples {                                                                       // [6] triples ::= subject predicateObjectList | blankNodePropertyList predicateObjectList?
  Subject predicateObjectList
  | BlankNodePropertyList predicateObjectList?
}
predicateObjectList { Verb objectList (';' (Verb objectList)?)* }               // [7] predicateObjectList ::= verb objectList (';' (verb objectList)?)*
objectList { Object (',' Object)* }                                             // [8] objectList ::= object (',' object)*
Verb { predicate | 'a' }                                                        // [9]  verb         ::= predicate | 'a'
Subject { iri | blanknode_rule /* incomplete rule */ }                               // [10] subject      ::= iri | BlankNode | collection
predicate { iri }                                                               // [11] predicate    ::= iri
Object { iri | blanknode_rule | Literal /* incomplete rule */ }                      // [12] object       ::= iri | BlankNode | collection | blankNodePropertyList | literal

BlankNodePropertyList { '[' predicateObjectList ']' }                           // [14] 	blankNodePropertyList 	::= 	'[' predicateObjectList ']'

iri { IRIREF | PrefixedName }                                                   // [135s] 	iri 	::= 	IRIREF | PrefixedName

// [136s] 	PrefixedName 	::= 	PNAME_LN | PNAME_NS
// PrefixedName { PNAME_LN }

PrefixedName { PN_PREFIX? ':' PN_LOCAL }

Literal { string_literal_quote }

blanknode_rule { BlankNode | Anon }                                             // [137s] 	BlankNode 	::= 	BLANK_NODE_LABEL | ANON


@tokens {
  @precedence { 'a', base_token, prefix_token, PN_PREFIX }

  IRIREF { '<' $[a-zA-Z_\-0-9/+.:#]* '>' }

  BlankNode { '_:' $[a-zA-Z0-9]+ }                                              // [141s] 	BLANK_NODE_LABEL 	::= 	'_:' (PN_CHARS_U | [0-9]) ((PN_CHARS | '.')* PN_CHARS)?

  string_literal_quote { '"' $[a-zA-Z0-9 _+]* '"' }

  "."

  LineComment { "#" ![\n]* }

  space { $[ \t\n\r]+ }

  PN_LOCAL { $[a-zA-Z0-9_]+ }

  PN_PREFIX { pn_chars_base+ }

  
  pn_chars_u { pn_chars_base | '_' }                                            // [164s] 	PN_CHARS_U 	::= 	PN_CHARS_BASE | '_'
  


  pn_chars_base { $[a-zA-Z0-9]+ }

  Anon { '[' space? ']' }                                                       // [162s] 	ANON 	::= 	'[' WS* ']'

  // TODO: case insensitive tokens
  base_token { "BASE" | "base" }
  prefix_token { "PREFIX" | "prefix" }

  
}

@detectDelim
